# Copyright 2025 The Torch-Spyre Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
PyTorch has 3000+ registered functions in aten, and some of these require registration to extend dispatcher.
There are three main ways to handle all wrapper functions depending on the backend support:

- implement each function
- use macros to reduce boilerplate code - hard to manage and debug though
- pre-compilation codegen to generate functions and registrations as most Torch device extensions do - requires managing templates as applicable.

This is the codegen script that can be called pre-compilation in setup.py to generate wrapper function implementations and dispatcher registrations
"""

import json
import os
import yaml
import argparse
from pathlib import Path
from typing import Union

import sys

# Adjust this to point to the root of your project
sys.path.insert(0, str(Path(__file__).resolve().parent))


from utils.template_tools import generate_replacements, generate_from_template


def insert_message_before_first_include(lines, message):
    # Find first line that starts with #include
    for i, line in enumerate(lines):
        if line.strip().startswith("#include"):
            lines.insert(i, message + "\n")
            break
    return lines


def generate_and_register_wrappers(codegen_dir: Union[str, Path]):
    """
    Generates the cpp file that implements wrapper functions and handles registrations for the dispatcher.

    Args:
        codegen_dir (str): Directory where all codegen files reside.
    """
    codegen_path = Path(codegen_dir).resolve()
    inputs_path = codegen_path / "inputs"
    outputs_path = codegen_path / "outputs"
    templates_path = codegen_path / "templates"

    print(os.getcwd())
    base_body_path = inputs_path / "spyre_torch_ops.cpp"
    with base_body_path.open("r") as f:
        body_content = f.read()

    # NOTE: If pytorch is not build from source, we need to copy these two files into (must be same torch version) the inputs folder.
    # These two files are auto generated by pytorch during build and helps us to understand the details of each aten operation in C++ api.
    # First is the schemas file is only required to see which aten ops are required to extend (the ones with dispatch=True, default=False).
    # Second is the declarations file containing detailed information about schema, arguments/returns properties etc.
    # Relying on these files is not ideal - but i could not find a reliable way to access these without build files internally.

    pytorch_schemas_path = inputs_path / "RegistrationDeclarations.h"
    pytorch_declarations_path = inputs_path / "Declarations.yaml"
    torch2sendnn_metadata_path = inputs_path / "Metadata.yaml"

    print("Parsing pytorch ops to generate replacement data.")

    # Get all schemas and declarations of pytorch ops
    with open(pytorch_schemas_path, "rt") as f:
        schemas = f.readlines()
    schemas = [
        json.loads(d.split("//")[-1]) for d in schemas[19:]
    ]  # extract schemas (skip frontmatter)

    with open(pytorch_declarations_path) as f:
        declarations = yaml.safe_load(f)

    with open(torch2sendnn_metadata_path) as f:
        metadata = yaml.safe_load(f)
        metadata = {item["operator_name"]: item for item in metadata}

    replacements = generate_replacements(declarations, schemas, metadata)

    # NOTE: I assume that we will have an existing C++ file (spyre_mem.cpp), which will be extended with the functions and registrations
    # generated by this module. However, we can directly write outputs to a completely separate cpp as well and bind later?
    comment_text = "This section is auto generated by codegen/gen.py."
    first_comment_text = f"// {comment_text}\n// " + "-" * len(comment_text) + "\n"
    second_comment_text = "// " + "-" * len(comment_text) + f"\n// {comment_text}\n"

    warning_msg = """// WARNING: THIS FILE IS AUTOGENERATED BY codegen. DO NOT MODIFY BY HAND.  """
    placeholder_text = "// INSERT_CODEGEN_HERE"
    body_content_lines = body_content.splitlines()
    placeholder_idx = body_content_lines.index(placeholder_text)
    body_content_parts = [
        "\n".join(
            insert_message_before_first_include(
                body_content_lines[:placeholder_idx], warning_msg
            )
        ),
        "\n".join(body_content_lines[placeholder_idx + 1 :]),
    ]
    cpp_output = body_content_parts[0] + first_comment_text

    template_name_list = [
        os.path.basename(p).split(".")[0] for p in templates_path.glob("*.jinja2")
    ]
    supported_ops = []

    for rep_data in replacements:
        template_name = rep_data["template_name"]
        if template_name not in template_name_list:
            # print(f"Warning: {rep_data['name']} - No template found for operation with template name {template_name}, skipping...")
            continue

        cpp_output += generate_from_template(templates_path, template_name, rep_data)
        supported_ops.append(rep_data)

    cpp_output += second_comment_text + body_content_parts[1]

    outputs_path.mkdir(exist_ok=True)
    output_file_path = outputs_path / "spyre_torch_ops.cpp"
    with output_file_path.open("w+") as f:
        f.write(cpp_output)

    out_declarations_path = outputs_path / "GeneratedDeclarations.yaml"
    with open(out_declarations_path, "w+") as f:
        yaml.dump(supported_ops, f, sort_keys=False)

    print([r["template_data"]["reg_name"] for r in supported_ops])
    print(
        f"Successfully generated {len(supported_ops)} operations and wrote to {output_file_path}."
    )
    return outputs_path


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--codegen_dir",
        type=str,
        default=os.getcwd(),
        help="codegen base directory",
    )
    args = parser.parse_args()

    generate_and_register_wrappers(args.codegen_dir)
